// Code generated by counterfeiter. DO NOT EDIT.
package boshfakes

import (
	sync "sync"

	bosh "github.com/cloudfoundry/bosh-deployment-resource/bosh"
	concourse "github.com/cloudfoundry/bosh-deployment-resource/concourse"
)

type FakeDirector struct {
	DeleteStub        func(bool) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 bool
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeployStub        func([]byte, bosh.DeployParams) error
	deployMutex       sync.RWMutex
	deployArgsForCall []struct {
		arg1 []byte
		arg2 bosh.DeployParams
	}
	deployReturns struct {
		result1 error
	}
	deployReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadManifestStub        func() ([]byte, error)
	downloadManifestMutex       sync.RWMutex
	downloadManifestArgsForCall []struct {
	}
	downloadManifestReturns struct {
		result1 []byte
		result2 error
	}
	downloadManifestReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ExportReleasesStub        func(string, []bosh.ReleaseSpec) error
	exportReleasesMutex       sync.RWMutex
	exportReleasesArgsForCall []struct {
		arg1 string
		arg2 []bosh.ReleaseSpec
	}
	exportReleasesReturns struct {
		result1 error
	}
	exportReleasesReturnsOnCall map[int]struct {
		result1 error
	}
	InterpolateStub        func([]byte, bosh.InterpolateParams) ([]byte, error)
	interpolateMutex       sync.RWMutex
	interpolateArgsForCall []struct {
		arg1 []byte
		arg2 bosh.InterpolateParams
	}
	interpolateReturns struct {
		result1 []byte
		result2 error
	}
	interpolateReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RunErrandStub        func(concourse.RunErrandParams) error
	runErrandMutex       sync.RWMutex
	runErrandArgsForCall []struct {
		arg1 concourse.RunErrandParams
	}
	runErrandReturns struct {
		result1 error
	}
	runErrandReturnsOnCall map[int]struct {
		result1 error
	}
	UploadReleaseStub        func(string) error
	uploadReleaseMutex       sync.RWMutex
	uploadReleaseArgsForCall []struct {
		arg1 string
	}
	uploadReleaseReturns struct {
		result1 error
	}
	uploadReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellStub        func(string) error
	uploadStemcellMutex       sync.RWMutex
	uploadStemcellArgsForCall []struct {
		arg1 string
	}
	uploadStemcellReturns struct {
		result1 error
	}
	uploadStemcellReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForDeployLockStub        func() error
	waitForDeployLockMutex       sync.RWMutex
	waitForDeployLockArgsForCall []struct {
	}
	waitForDeployLockReturns struct {
		result1 error
	}
	waitForDeployLockReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDirector) Delete(arg1 bool) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeDirector) DeleteCalls(stub func(bool) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeDirector) DeleteArgsForCall(i int) bool {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) Deploy(arg1 []byte, arg2 bosh.DeployParams) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deployMutex.Lock()
	ret, specificReturn := fake.deployReturnsOnCall[len(fake.deployArgsForCall)]
	fake.deployArgsForCall = append(fake.deployArgsForCall, struct {
		arg1 []byte
		arg2 bosh.DeployParams
	}{arg1Copy, arg2})
	fake.recordInvocation("Deploy", []interface{}{arg1Copy, arg2})
	fake.deployMutex.Unlock()
	if fake.DeployStub != nil {
		return fake.DeployStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deployReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) DeployCallCount() int {
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	return len(fake.deployArgsForCall)
}

func (fake *FakeDirector) DeployCalls(stub func([]byte, bosh.DeployParams) error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = stub
}

func (fake *FakeDirector) DeployArgsForCall(i int) ([]byte, bosh.DeployParams) {
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	argsForCall := fake.deployArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) DeployReturns(result1 error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = nil
	fake.deployReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DeployReturnsOnCall(i int, result1 error) {
	fake.deployMutex.Lock()
	defer fake.deployMutex.Unlock()
	fake.DeployStub = nil
	if fake.deployReturnsOnCall == nil {
		fake.deployReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deployReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DownloadManifest() ([]byte, error) {
	fake.downloadManifestMutex.Lock()
	ret, specificReturn := fake.downloadManifestReturnsOnCall[len(fake.downloadManifestArgsForCall)]
	fake.downloadManifestArgsForCall = append(fake.downloadManifestArgsForCall, struct {
	}{})
	fake.recordInvocation("DownloadManifest", []interface{}{})
	fake.downloadManifestMutex.Unlock()
	if fake.DownloadManifestStub != nil {
		return fake.DownloadManifestStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.downloadManifestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DownloadManifestCallCount() int {
	fake.downloadManifestMutex.RLock()
	defer fake.downloadManifestMutex.RUnlock()
	return len(fake.downloadManifestArgsForCall)
}

func (fake *FakeDirector) DownloadManifestCalls(stub func() ([]byte, error)) {
	fake.downloadManifestMutex.Lock()
	defer fake.downloadManifestMutex.Unlock()
	fake.DownloadManifestStub = stub
}

func (fake *FakeDirector) DownloadManifestReturns(result1 []byte, result2 error) {
	fake.downloadManifestMutex.Lock()
	defer fake.downloadManifestMutex.Unlock()
	fake.DownloadManifestStub = nil
	fake.downloadManifestReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DownloadManifestReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.downloadManifestMutex.Lock()
	defer fake.downloadManifestMutex.Unlock()
	fake.DownloadManifestStub = nil
	if fake.downloadManifestReturnsOnCall == nil {
		fake.downloadManifestReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.downloadManifestReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ExportReleases(arg1 string, arg2 []bosh.ReleaseSpec) error {
	var arg2Copy []bosh.ReleaseSpec
	if arg2 != nil {
		arg2Copy = make([]bosh.ReleaseSpec, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.exportReleasesMutex.Lock()
	ret, specificReturn := fake.exportReleasesReturnsOnCall[len(fake.exportReleasesArgsForCall)]
	fake.exportReleasesArgsForCall = append(fake.exportReleasesArgsForCall, struct {
		arg1 string
		arg2 []bosh.ReleaseSpec
	}{arg1, arg2Copy})
	fake.recordInvocation("ExportReleases", []interface{}{arg1, arg2Copy})
	fake.exportReleasesMutex.Unlock()
	if fake.ExportReleasesStub != nil {
		return fake.ExportReleasesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.exportReleasesReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) ExportReleasesCallCount() int {
	fake.exportReleasesMutex.RLock()
	defer fake.exportReleasesMutex.RUnlock()
	return len(fake.exportReleasesArgsForCall)
}

func (fake *FakeDirector) ExportReleasesCalls(stub func(string, []bosh.ReleaseSpec) error) {
	fake.exportReleasesMutex.Lock()
	defer fake.exportReleasesMutex.Unlock()
	fake.ExportReleasesStub = stub
}

func (fake *FakeDirector) ExportReleasesArgsForCall(i int) (string, []bosh.ReleaseSpec) {
	fake.exportReleasesMutex.RLock()
	defer fake.exportReleasesMutex.RUnlock()
	argsForCall := fake.exportReleasesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) ExportReleasesReturns(result1 error) {
	fake.exportReleasesMutex.Lock()
	defer fake.exportReleasesMutex.Unlock()
	fake.ExportReleasesStub = nil
	fake.exportReleasesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) ExportReleasesReturnsOnCall(i int, result1 error) {
	fake.exportReleasesMutex.Lock()
	defer fake.exportReleasesMutex.Unlock()
	fake.ExportReleasesStub = nil
	if fake.exportReleasesReturnsOnCall == nil {
		fake.exportReleasesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exportReleasesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) Interpolate(arg1 []byte, arg2 bosh.InterpolateParams) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.interpolateMutex.Lock()
	ret, specificReturn := fake.interpolateReturnsOnCall[len(fake.interpolateArgsForCall)]
	fake.interpolateArgsForCall = append(fake.interpolateArgsForCall, struct {
		arg1 []byte
		arg2 bosh.InterpolateParams
	}{arg1Copy, arg2})
	fake.recordInvocation("Interpolate", []interface{}{arg1Copy, arg2})
	fake.interpolateMutex.Unlock()
	if fake.InterpolateStub != nil {
		return fake.InterpolateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.interpolateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) InterpolateCallCount() int {
	fake.interpolateMutex.RLock()
	defer fake.interpolateMutex.RUnlock()
	return len(fake.interpolateArgsForCall)
}

func (fake *FakeDirector) InterpolateCalls(stub func([]byte, bosh.InterpolateParams) ([]byte, error)) {
	fake.interpolateMutex.Lock()
	defer fake.interpolateMutex.Unlock()
	fake.InterpolateStub = stub
}

func (fake *FakeDirector) InterpolateArgsForCall(i int) ([]byte, bosh.InterpolateParams) {
	fake.interpolateMutex.RLock()
	defer fake.interpolateMutex.RUnlock()
	argsForCall := fake.interpolateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) InterpolateReturns(result1 []byte, result2 error) {
	fake.interpolateMutex.Lock()
	defer fake.interpolateMutex.Unlock()
	fake.InterpolateStub = nil
	fake.interpolateReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) InterpolateReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.interpolateMutex.Lock()
	defer fake.interpolateMutex.Unlock()
	fake.InterpolateStub = nil
	if fake.interpolateReturnsOnCall == nil {
		fake.interpolateReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.interpolateReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RunErrand(arg1 concourse.RunErrandParams) error {
	fake.runErrandMutex.Lock()
	ret, specificReturn := fake.runErrandReturnsOnCall[len(fake.runErrandArgsForCall)]
	fake.runErrandArgsForCall = append(fake.runErrandArgsForCall, struct {
		arg1 concourse.RunErrandParams
	}{arg1})
	fake.recordInvocation("RunErrand", []interface{}{arg1})
	fake.runErrandMutex.Unlock()
	if fake.RunErrandStub != nil {
		return fake.RunErrandStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.runErrandReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) RunErrandCallCount() int {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	return len(fake.runErrandArgsForCall)
}

func (fake *FakeDirector) RunErrandCalls(stub func(concourse.RunErrandParams) error) {
	fake.runErrandMutex.Lock()
	defer fake.runErrandMutex.Unlock()
	fake.RunErrandStub = stub
}

func (fake *FakeDirector) RunErrandArgsForCall(i int) concourse.RunErrandParams {
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	argsForCall := fake.runErrandArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) RunErrandReturns(result1 error) {
	fake.runErrandMutex.Lock()
	defer fake.runErrandMutex.Unlock()
	fake.RunErrandStub = nil
	fake.runErrandReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) RunErrandReturnsOnCall(i int, result1 error) {
	fake.runErrandMutex.Lock()
	defer fake.runErrandMutex.Unlock()
	fake.RunErrandStub = nil
	if fake.runErrandReturnsOnCall == nil {
		fake.runErrandReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runErrandReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadRelease(arg1 string) error {
	fake.uploadReleaseMutex.Lock()
	ret, specificReturn := fake.uploadReleaseReturnsOnCall[len(fake.uploadReleaseArgsForCall)]
	fake.uploadReleaseArgsForCall = append(fake.uploadReleaseArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UploadRelease", []interface{}{arg1})
	fake.uploadReleaseMutex.Unlock()
	if fake.UploadReleaseStub != nil {
		return fake.UploadReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadReleaseReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadReleaseCallCount() int {
	fake.uploadReleaseMutex.RLock()
	defer fake.uploadReleaseMutex.RUnlock()
	return len(fake.uploadReleaseArgsForCall)
}

func (fake *FakeDirector) UploadReleaseCalls(stub func(string) error) {
	fake.uploadReleaseMutex.Lock()
	defer fake.uploadReleaseMutex.Unlock()
	fake.UploadReleaseStub = stub
}

func (fake *FakeDirector) UploadReleaseArgsForCall(i int) string {
	fake.uploadReleaseMutex.RLock()
	defer fake.uploadReleaseMutex.RUnlock()
	argsForCall := fake.uploadReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) UploadReleaseReturns(result1 error) {
	fake.uploadReleaseMutex.Lock()
	defer fake.uploadReleaseMutex.Unlock()
	fake.UploadReleaseStub = nil
	fake.uploadReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseReturnsOnCall(i int, result1 error) {
	fake.uploadReleaseMutex.Lock()
	defer fake.uploadReleaseMutex.Unlock()
	fake.UploadReleaseStub = nil
	if fake.uploadReleaseReturnsOnCall == nil {
		fake.uploadReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcell(arg1 string) error {
	fake.uploadStemcellMutex.Lock()
	ret, specificReturn := fake.uploadStemcellReturnsOnCall[len(fake.uploadStemcellArgsForCall)]
	fake.uploadStemcellArgsForCall = append(fake.uploadStemcellArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UploadStemcell", []interface{}{arg1})
	fake.uploadStemcellMutex.Unlock()
	if fake.UploadStemcellStub != nil {
		return fake.UploadStemcellStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadStemcellReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadStemcellCallCount() int {
	fake.uploadStemcellMutex.RLock()
	defer fake.uploadStemcellMutex.RUnlock()
	return len(fake.uploadStemcellArgsForCall)
}

func (fake *FakeDirector) UploadStemcellCalls(stub func(string) error) {
	fake.uploadStemcellMutex.Lock()
	defer fake.uploadStemcellMutex.Unlock()
	fake.UploadStemcellStub = stub
}

func (fake *FakeDirector) UploadStemcellArgsForCall(i int) string {
	fake.uploadStemcellMutex.RLock()
	defer fake.uploadStemcellMutex.RUnlock()
	argsForCall := fake.uploadStemcellArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) UploadStemcellReturns(result1 error) {
	fake.uploadStemcellMutex.Lock()
	defer fake.uploadStemcellMutex.Unlock()
	fake.UploadStemcellStub = nil
	fake.uploadStemcellReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellReturnsOnCall(i int, result1 error) {
	fake.uploadStemcellMutex.Lock()
	defer fake.uploadStemcellMutex.Unlock()
	fake.UploadStemcellStub = nil
	if fake.uploadStemcellReturnsOnCall == nil {
		fake.uploadStemcellReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) WaitForDeployLock() error {
	fake.waitForDeployLockMutex.Lock()
	ret, specificReturn := fake.waitForDeployLockReturnsOnCall[len(fake.waitForDeployLockArgsForCall)]
	fake.waitForDeployLockArgsForCall = append(fake.waitForDeployLockArgsForCall, struct {
	}{})
	fake.recordInvocation("WaitForDeployLock", []interface{}{})
	fake.waitForDeployLockMutex.Unlock()
	if fake.WaitForDeployLockStub != nil {
		return fake.WaitForDeployLockStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitForDeployLockReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) WaitForDeployLockCallCount() int {
	fake.waitForDeployLockMutex.RLock()
	defer fake.waitForDeployLockMutex.RUnlock()
	return len(fake.waitForDeployLockArgsForCall)
}

func (fake *FakeDirector) WaitForDeployLockCalls(stub func() error) {
	fake.waitForDeployLockMutex.Lock()
	defer fake.waitForDeployLockMutex.Unlock()
	fake.WaitForDeployLockStub = stub
}

func (fake *FakeDirector) WaitForDeployLockReturns(result1 error) {
	fake.waitForDeployLockMutex.Lock()
	defer fake.waitForDeployLockMutex.Unlock()
	fake.WaitForDeployLockStub = nil
	fake.waitForDeployLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) WaitForDeployLockReturnsOnCall(i int, result1 error) {
	fake.waitForDeployLockMutex.Lock()
	defer fake.waitForDeployLockMutex.Unlock()
	fake.WaitForDeployLockStub = nil
	if fake.waitForDeployLockReturnsOnCall == nil {
		fake.waitForDeployLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForDeployLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deployMutex.RLock()
	defer fake.deployMutex.RUnlock()
	fake.downloadManifestMutex.RLock()
	defer fake.downloadManifestMutex.RUnlock()
	fake.exportReleasesMutex.RLock()
	defer fake.exportReleasesMutex.RUnlock()
	fake.interpolateMutex.RLock()
	defer fake.interpolateMutex.RUnlock()
	fake.runErrandMutex.RLock()
	defer fake.runErrandMutex.RUnlock()
	fake.uploadReleaseMutex.RLock()
	defer fake.uploadReleaseMutex.RUnlock()
	fake.uploadStemcellMutex.RLock()
	defer fake.uploadStemcellMutex.RUnlock()
	fake.waitForDeployLockMutex.RLock()
	defer fake.waitForDeployLockMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDirector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bosh.Director = new(FakeDirector)
